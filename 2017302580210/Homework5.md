## \Homework5

> 2017302580210 于佳艺

### 一、checksum

1、 先将需要计算checksum数据中的checksum设为0； 
2、 计算checksum的数据按2byte划分开来，每2byte组成一个16bit的值，如果最后有单个byte的数据，补一个byte的0组成2byte； 
3、 将所有的16bit值累加到一个32bit的值中； 
4、 将32bit值的高16bit与低16bit相加到一个新的32bit值中，若新的32bit值大于0Xffff, 
再将新值的高16bit与低16bit相加； 
5、 将上一步计算所得的16bit值按位取反，即得到checksum值，存入数据的checksum字段即可。

PS:  求和时可以先求和再取反（反码），或取反后再求和（用反码求和），二者是等价的。 

代码如下：

<img src="image\checksum.png">

运行，结果与课本相同，如下：

<img src="image\result.png">

### 二、课后题

##### P3.

UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节：01010011, 01100110, 01110100.这些8比特字节和的反码是多少？（注意到尽管UDP和TCP使用16比特的字来计算检验 和，但对于这个问题，你应该考虑8比特和。）写岀所有工作过程。UDP为什么要用该和的反码，即 为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错？ 1比特的差错将可能检测不出 来吗？ 2比特的差错呢？

##### 解：

  01010011

+01100110

=10111001

+01110100

=00101101

把溢出的1加到最低位：00101110

~00101110=11010001

校验时直接将数据相加，如果其中包含0则说明出现差错，检验简单方便。

1比特差错可以检测出

2比特差错不能检测

##### P14 

我们曾经说过，应用程序可能选择UDP作为运输协议，因为UDP提供了（比TCP更好的应用层 控制，以决定在报文段中发送什么数据和发送时机。 a.应用程序为什么对在报文段中发送什么数据有更多的控制？ b-应用程序为什么对何时发送报文段有更多的控制？

##### 解：

a)考虑在传输协议上发送应用消息。使用TCP，应用程序将数据写入连接发送缓冲区，TCP将抓取字节必须在TCP段中放置一个消息；TCP可能会或多或少地发送消息而不是在段中的单个消息。另一方面，UDP封装在无论应用程序给出什么，都会分段；因此，如果应用程序提供UDP应用消息，此消息将是UDP段的有效负载。因此,对于UDP，应用程序对数据段中的数据进行了更多控制。

b)由于流量控制和拥塞控制，TCP由于流量控制和拥塞控制，可能会有显著的延迟从应用程序向其发送缓冲器写入数据直到数据被指定给网络层。UDP由于流控制而没有延迟,拥塞控制。